<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Recommendation System</title>
    <style>
        /* 1. Color Scheme and Branding */
        :root {
            /* Light theme variables */
            --primary: #4D7CFE;
            --primary-dark: #3D63CB;
            --secondary: #FF6B6B;
            --background: #f0f7ff;
            --surface: #ffffff;
            --text: #2D3748;
            --text-light: #4A5568;
            --error: #FF6B6B;
            --success: #4ECDC4;

            /* Dark theme variables */
            --dark-background: #1a1a1a;
            --dark-surface: #2d2d2d;
            --dark-text: #ffffff;
            --dark-text-light: #a1a1aa;
        }

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background: var(--background);
            color: var(--text);
            line-height: 1.6;
        }

        /* 2. Typography Improvements */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap');

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Chakra Petch', sans-serif;
            letter-spacing: -0.025em;
            text-transform: uppercase;
            font-weight: 600;
        }

        header h1 {
            font-size: 2.8rem;
            color: white;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
            font-weight: 700;
            letter-spacing: -0.02em;
            transform: none;  /* Remove the rotation for a more tech feel */
        }

        header h1:hover {
            transform: rotate(2deg);
        }

        h2 {
            font-size: 1.875rem;
            font-weight: 600;
            color: var(--primary);
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0.75rem 0;
        }

        /* 3. Card Design Enhancements */
        .game {
            border-radius: 20px;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 3px solid transparent;
            background: linear-gradient(var(--surface), var(--surface)) padding-box,
                        linear-gradient(45deg, #ff6b6b, #4ecdc4) border-box;
        }

        .game:hover {
            transform: translateY(-8px) rotate(2deg);
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                0 0 15px rgba(77, 171, 247, 0.5);
        }

        .game img {
            border-radius: 15px;
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .game:hover img {
            transform: scale(1.08);
        }

        .game.selected {
            animation: bounce 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 3px solid var(--primary);
            box-shadow: 
                0 0 0 4px rgba(77, 124, 254, 0.2),
                0 8px 16px rgba(0, 0, 0, 0.1);
        }

        .game.selected::after {
            content: '✓';
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--primary);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* Add dark mode support for selected games */
        [data-theme="dark"] .game.selected {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(96, 165, 250, 0.1);
        }

        /* 4. Layout Refinements */
        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            background: linear-gradient(135deg, #4D7CFE, #3D63CB, #6C5CE7);
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.1;
        }

        .search-container {
            background: var(--surface);
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
        }

        #game-search, #platform-filter {
            padding: 0.75rem 1rem;
            border: 2px solid #e2e8f0;
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        #game-search:focus, #platform-filter:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            outline: none;
        }

        /* 5. Interactive Elements */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .loading {
            animation: pulse 1.5s ease-in-out infinite;
        }

        .game button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .game button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .match-details {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 3;
        }

        .game:hover .match-details {
            transform: translateY(0);
        }

        .game-details {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid #e2e8f0;
            font-size: 0.8125rem;
        }

        .game-details p {
            margin: 0.25rem 0;
            line-height: 1.4;
        }

        .game-details strong {
            color: var(--text);
            font-weight: 500;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            main {
                padding: 1rem;
            }

            .game {
                min-height: auto;
            }

            #game-list, #recommendation-list, #selected-games-list {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }

            .search-container {
                flex-direction: column;
            }

            #game-search, #platform-filter {
                width: 100%;
                margin-bottom: 0.5rem;
            }
        }

        /* Loading Skeleton Animation */
        @keyframes shimmer {
            0% {
                background-position: -468px 0;
            }
            100% {
                background-position: 468px 0;
            }
        }

        .skeleton {
            background: #f6f7f8;
            background-image: linear-gradient(
                to right,
                #f6f7f8 0%,
                #edeef1 20%,
                #f6f7f8 40%,
                #f6f7f8 100%
            );
            background-repeat: no-repeat;
            background-size: 800px 104px;
            animation: shimmer 1.5s infinite linear;
        }

        /* Tooltips */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]:before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.5rem;
            background: var(--text);
            color: white;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
        }

        [data-tooltip]:hover:before {
            opacity: 1;
            visibility: visible;
        }

        /* Update the game card and grid styling */
        .game {
            background: var(--surface);
            border-radius: 0.75rem;
            padding: 0.75rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                        0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .game img {
            border-radius: 0.5rem;
            transition: transform 0.3s ease;
            width: 100%;
            height: 140px;
            object-fit: cover;
        }

        /* Adjust typography */
        .game h3 {
            font-size: 1rem;
            margin: 0.5rem 0;
            line-height: 1.2;
            font-family: 'Chakra Petch', sans-serif;
            font-weight: 600;
            letter-spacing: -0.01em;
            transform: none;  /* Remove the rotation for a more tech feel */
        }

        .game-details {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid #e2e8f0;
            font-size: 0.8125rem;
        }

        .game-details p {
            margin: 0.25rem 0;
            line-height: 1.4;
        }

        /* Grid layout adjustments */
        #game-list, #recommendation-list, #selected-games-list {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }

        /* Responsive adjustments */
        @media (min-width: 1200px) {
            #game-list, #recommendation-list, #selected-games-list {
                grid-template-columns: repeat(5, 1fr);
            }
        }

        @media (max-width: 1199px) and (min-width: 768px) {
            #game-list, #recommendation-list, #selected-games-list {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 767px) {
            #game-list, #recommendation-list, #selected-games-list {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Add these styles for the recommendation sections */
        .recommendation-section {
            margin-bottom: 2rem;
        }

        .recommendation-container {
            display: flex;
            justify-content: space-between;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .recommendation-section {
            flex: 1;
            max-width: calc(50% - 1rem);  /* Take up half the space minus gap */
        }

        .section-title {
            font-size: 1.5rem;
            color: var(--primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary);
            font-family: 'Chakra Petch', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .section-games {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(2, minmax(200px, 1fr));  /* Match the main grid constraints */
        }

        /* Remove any specific .game styles that might be conflicting in the sections */
        .recommendation-section .game {
            width: auto;
            height: auto;
        }

        /* Update the dark mode styles */
        [data-theme="dark"] {
            --background: var(--dark-background);
            --surface: var(--dark-surface);
            --text: var(--dark-text);
            --text-light: var(--dark-text-light);
            --primary: #60a5fa;  /* Lighter blue for better contrast */
            --primary-dark: #3b82f6;
        }

        [data-theme="dark"] .game {
            background: linear-gradient(var(--surface), var(--surface)) padding-box,
                        linear-gradient(45deg, #4D7CFE, #6C5CE7) border-box;
        }

        [data-theme="dark"] .search-container {
            background-color: var(--dark-surface);
        }

        [data-theme="dark"] #game-search,
        [data-theme="dark"] #platform-filter {
            background-color: var(--dark-surface);
            color: var(--dark-text);
            border-color: rgba(255, 255, 255, 0.1);
        }

        [data-theme="dark"] .game-details {
            border-top-color: rgba(255, 255, 255, 0.1);
        }

        [data-theme="dark"] .section-title {
            border-bottom-color: var(--primary);
        }

        [data-theme="dark"] .match-details {
            background: rgba(30, 41, 59, 0.95);
            color: var(--dark-text);
        }

        /* Add theme switch styles */
        .theme-switch-wrapper {
            display: flex;
            align-items: center;
            position: absolute;
            right: 2rem;
            top: 2rem;
        }

        .theme-switch-wrapper em {
            margin-left: 10px;
            font-size: 1rem;
            color: var(--surface);
        }

        .theme-switch {
            display: inline-block;
            height: 34px;
            position: relative;
            width: 60px;
        }

        .theme-switch input {
            display: none;
        }

        .slider {
            background-color: #ccc;
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
        }

        .slider:before {
            background-color: #fff;
            bottom: 4px;
            content: "";
            height: 26px;
            left: 4px;
            position: absolute;
            transition: .4s;
            width: 26px;
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        /* Star styling */
        .popular-star {
            position: absolute;
            top: 8px;
            left: 8px;
            color: gold;
            font-size: 28px;
            z-index: 4;
            text-shadow: 
                0 0 10px rgba(255, 215, 0, 0.7),
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                2px 2px 0 #000;
            transform-origin: center;
            transition: transform 0.3s ease;
        }

        /* Update star animation speed and timing */
        @keyframes starSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .game:hover .popular-star {
            animation: starSpin 1.5s cubic-bezier(0.4, 0, 0.2, 1);  /* Slower spin with smooth easing */
        }

        /* 1. Typography Updates */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=Roboto:wght@400;500;700&display=swap');

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Chakra Petch', sans-serif;
            letter-spacing: -0.025em;
            text-transform: uppercase;
            font-weight: 600;
        }

        body {
            font-family: 'Roboto', sans-serif;
        }

        header h1 {
            font-size: 2.8rem;
            color: white;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
            font-weight: 700;
            letter-spacing: -0.02em;
            transform: none;  /* Remove the rotation for a more tech feel */
        }

        .section-title {
            font-family: 'Chakra Petch', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .game h3 {
            font-family: 'Chakra Petch', sans-serif;
            font-weight: 600;
            letter-spacing: -0.01em;
            transform: none;  /* Remove the rotation for a more tech feel */
        }

        /* Update popup typography */
        .popup-title {
            font-family: 'Chakra Petch', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: -0.02em;
        }

        .detail-section h3 {
            font-family: 'Chakra Petch', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }

        /* 2. Card Design Updates */
        .game {
            border-radius: 20px;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 3px solid transparent;
            background: linear-gradient(var(--surface), var(--surface)) padding-box,
                        linear-gradient(45deg, #ff6b6b, #4ecdc4) border-box;
        }

        .game:hover {
            transform: translateY(-8px) rotate(2deg);
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                0 0 15px rgba(77, 171, 247, 0.5);
        }

        .game img {
            border-radius: 15px;
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .game:hover img {
            transform: scale(1.08);
        }

        /* 3. Color Scheme Updates */
        :root {
            --primary: #4D7CFE;
            --primary-dark: #3D63CB;
            --secondary: #FF6B6B;
            --background: #f0f7ff;
            --surface: #ffffff;
            --text: #2D3748;
            --text-light: #4A5568;
            --error: #FF6B6B;
            --success: #4ECDC4;
        }

        header {
            background: linear-gradient(135deg, #4D7CFE, #3D63CB, #6C5CE7);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.1;
        }

        /* 4. Animation Updates */
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0); }
            50% { transform: translateY(-5px) rotate(2deg); }
        }

        .game.selected {
            animation: bounce 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 3px solid var(--primary);
            box-shadow: 
                0 0 0 4px rgba(77, 124, 254, 0.2),
                0 8px 16px rgba(0, 0, 0, 0.1);
        }

        .popular-star {
            animation: float 3s ease-in-out infinite;
        }

        .game:hover .popular-star {
            animation: starSpin 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* Update button styles */
        button {
            border-radius: 15px;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform-origin: center;
        }

        button:hover {
            transform: scale(1.05) rotate(-2deg);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        /* Dark mode adjustments */
        [data-theme="dark"] {
            --background: #1a1f2c;
            --surface: #2d3748;
            --text: #ffffff;
            --text-light: #cbd5e0;
        }

        [data-theme="dark"] .game {
            background: linear-gradient(var(--surface), var(--surface)) padding-box,
                        linear-gradient(45deg, #4D7CFE, #6C5CE7) border-box;
        }

        /* Add random movement animation keyframes */
        @keyframes wiggle1 {
            0%, 100% { transform: translateY(-8px) rotate(2deg); }
            50% { transform: translateY(-12px) rotate(-2deg); }
        }

        @keyframes wiggle2 {
            0%, 100% { transform: translateX(5px) translateY(-10px) rotate(-3deg); }
            50% { transform: translateX(-5px) translateY(-6px) rotate(1deg); }
        }

        @keyframes wiggle3 {
            0%, 100% { transform: translateY(-15px) rotate(1deg); }
            50% { transform: translateY(-5px) rotate(-1deg); }
        }

        @keyframes wiggle4 {
            0%, 100% { transform: translateX(-8px) translateY(-8px) rotate(-2deg); }
            50% { transform: translateX(8px) translateY(-12px) rotate(2deg); }
        }

        /* Update game card hover with random animations */
        .game {
            border-radius: 20px;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            border: 3px solid transparent;
            background: linear-gradient(var(--surface), var(--surface)) padding-box,
                        linear-gradient(45deg, #ff6b6b, #4ecdc4) border-box;
        }

        .game:nth-child(4n+1):hover {
            animation: wiggle1 1s infinite;
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                0 0 15px rgba(77, 171, 247, 0.5);
        }

        .game:nth-child(4n+2):hover {
            animation: wiggle2 1s infinite;
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                0 0 15px rgba(77, 171, 247, 0.5);
        }

        .game:nth-child(4n+3):hover {
            animation: wiggle3 1s infinite;
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                0 0 15px rgba(77, 171, 247, 0.5);
        }

        .game:nth-child(4n+4):hover {
            animation: wiggle4 1s infinite;
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.1),
                0 10px 10px -5px rgba(0, 0, 0, 0.04),
                0 0 15px rgba(77, 171, 247, 0.5);
        }

        /* Add spin animation for the diamond */
        @keyframes gemSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .gem-icon {
            position: absolute;
            top: 8px;
            left: 8px;
            font-size: 32px;
            z-index: 4;
            animation: shimmer 2s infinite;
            text-shadow: 
                0 0 10px rgba(147,112,219, 0.7),
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                2px 2px 0 #000;
        }

        /* Add hover spin effect */
        .game:hover .gem-icon {
            animation: gemSpin 1.5s cubic-bezier(0.4, 0, 0.2, 1);  /* Same timing as star spin */
        }

        /* Keep the existing star animation */
        .game:hover .popular-star {
            animation: starSpin 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .game-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
        }

        .popup-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .popup-content {
            position: relative;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            margin: 5vh auto;
            background: var(--surface);
            border-radius: 16px;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            animation: popup-slide-up 0.3s ease-out;
        }

        .popup-header {
            position: relative;
            width: 100%;
            height: 400px;
        }

        .popup-image-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .popup-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .popup-title-section {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 100px 40px 40px;
            background: linear-gradient(transparent, rgba(0,0,0,0.9));
            color: white;
        }

        .popup-title {
            font-size: 3rem;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .popup-body {
            padding: 40px;
        }

        .close-popup {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            z-index: 2;
            transition: background 0.3s;
        }

        .close-popup:hover {
            background: rgba(0,0,0,0.8);
        }

        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .detail-section {
            background: var(--background);
            padding: 20px;
            border-radius: 10px;
        }

        @keyframes popup-slide-up {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        [data-theme="dark"] .popup-content {
            background: var(--dark-surface);
            color: var(--dark-text);
        }

        /* Add these styles */
        .platforms-grid, .genres-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 15px;
        }

        .platform-tag, .genre-tag {
            background: rgba(48, 51, 61, 0.95);
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .platform-tag:hover, .genre-tag:hover {
            background: rgba(71, 76, 89, 0.95);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .platform-name, .genre-name {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.9rem;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .detail-section {
            background: rgba(30, 32, 37, 0.95);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .detail-section h3 {
            color: #E6E8EC;
            font-size: 1.1rem;
            font-weight: 500;
            margin: 0 0 15px 0;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            opacity: 0.9;
        }

        .platforms-section, .genres-section {
            transition: all 0.3s ease;
        }

        .platforms-section:hover, .genres-section:hover {
            background: rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        #selected-counter {
            color: #fff;
            font-size: 0.9rem;
            margin-right: 15px;
        }

        #clear-selection {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 5px;
            transition: all 0.2s ease;
            display: none;
        }

        #clear-selection:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        #get-recommendations {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #get-recommendations:hover:not(.disabled) {
            background: #45a049;
            transform: translateY(-2px);
        }

        #get-recommendations.disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Update the selected games list styling */
        #selected-games-list {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }

        #selected-games-list .game {
            background: var(--surface);
            border-radius: 0.75rem;
            padding: 0.75rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 
                        0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        #selected-games-list .game img {
            width: 100%;
            height: 140px;
            object-fit: cover;
            border-radius: 0.5rem;
            transition: transform 0.3s ease;
        }

        #selected-games-list .game h3 {
            font-size: 1rem;
            margin: 0.5rem 0;
            line-height: 1.2;
        }

        #selected-games-list .game-details {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid #e2e8f0;
            font-size: 0.8125rem;
        }

        #selected-games-list .game-details p {
            margin: 0.25rem 0;
            line-height: 1.4;
        }

        /* Add styles for the stores section */
        .stores-section {
            background: rgba(30, 32, 37, 0.95);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stores-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 15px;
        }

        .store-tag {
            background: rgba(48, 51, 61, 0.95);
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-decoration: none;
            color: rgba(255, 255, 255, 0.9);
        }

        .store-tag:hover {
            background: rgba(71, 76, 89, 0.95);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .store-name {
            font-size: 0.9rem;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* Dark mode support */
        [data-theme="dark"] .store-tag {
            background: rgba(48, 51, 61, 0.95);
            color: var(--dark-text);
        }

        [data-theme="dark"] .store-tag:hover {
            background: rgba(71, 76, 89, 0.95);
        }

        /* Dark mode styles */
        [data-theme="dark"] {
            --background: var(--dark-background);
            --surface: var(--dark-surface);
            --text: var(--dark-text);
            --text-light: var(--dark-text-light);
        }

        [data-theme="dark"] body {
            background: var(--dark-background);
            color: var(--dark-text);
        }

        [data-theme="dark"] .game {
            background: var(--dark-surface);
            border-color: rgba(255, 255, 255, 0.1);
        }

        [data-theme="dark"] .game h3 {
            color: var(--dark-text);
        }

        [data-theme="dark"] .game-details {
            color: var(--dark-text-light);
        }

        [data-theme="dark"] .search-container {
            background: var(--dark-surface);
        }

        [data-theme="dark"] #game-search,
        [data-theme="dark"] #platform-filter {
            background: var(--dark-surface);
            color: var(--dark-text);
            border-color: rgba(255, 255, 255, 0.1);
        }

        [data-theme="dark"] .section-title {
            color: var(--primary);
        }

        [data-theme="dark"] .match-details {
            background: rgba(30, 41, 59, 0.95);
            color: var(--dark-text);
        }

        [data-theme="dark"] .popup-content {
            background: var(--dark-surface);
            color: var(--dark-text);
        }

        [data-theme="dark"] .detail-section {
            background: var(--dark-background);
        }

        [data-theme="dark"] .platform-tag,
        [data-theme="dark"] .genre-tag,
        [data-theme="dark"] .store-tag {
            background: rgba(48, 51, 61, 0.95);
            color: var(--dark-text);
            border-color: rgba(255, 255, 255, 0.1);
        }

        [data-theme="dark"] .platform-tag:hover,
        [data-theme="dark"] .genre-tag:hover,
        [data-theme="dark"] .store-tag:hover {
            background: rgba(71, 76, 89, 0.95);
        }

        [data-theme="dark"] .popup-overlay {
            background: rgba(0, 0, 0, 0.8);
        }

        [data-theme="dark"] .description {
            color: var(--dark-text);
        }

        [data-theme="dark"] .popup-meta {
            color: var(--dark-text-light);
        }

        [data-theme="dark"] .close-popup {
            background: rgba(255, 255, 255, 0.1);
            color: var(--dark-text);
        }

        [data-theme="dark"] .close-popup:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .comments-section {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .comments-container {
            margin-bottom: 1rem;
        }

        .comment {
            background: rgba(48, 51, 61, 0.95);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            color: var(--dark-text);
            position: relative;
        }

        .comment-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: absolute;
            left: -50px;
            top: 10px;
        }

        .comment-content {
            margin-left: 50px; /* Space for the avatar */
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .comment-author {
            font-weight: bold;
            color: var(--primary);
        }

        .comment-date {
            font-size: 0.8rem;
            color: var(--dark-text-light);
        }

        .comment-text {
            margin: 0.5rem 0;
        }

        .comment-actions {
            margin-top: 0.5rem;
        }

        .reply-button {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .reply-button:hover {
            background: var(--primary-dark);
        }

        .reply-form {
            display: none; /* Initially hidden */
            margin-top: 1rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 10px;
        }

        .reply-form.active {
            display: block; /* Show when active */
        }

        .hidden {
            display: none; /* Class to hide elements */
        }

        .reply-form input,
        .reply-form textarea {
            width: 100%;
            padding: 0.5rem;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: var(--dark-text);
        }

        .reply-form button {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .reply-form button:hover {
            background: var(--primary-dark);
        }

        .replies-container {
            margin-left: 2rem;
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <header>
        <h1>Game Recommendation System</h1>
        <!-- Add theme toggle switch -->
        <div class="theme-switch-wrapper">
            <label class="theme-switch" for="checkbox">
                <input type="checkbox" id="checkbox" />
                <div class="slider round"></div>
            </label>
            <em>Dark Mode</em>
        </div>
    </header>
    <main>
        <section id="selected-games">
            <h2>Your Selected Games:</h2>
            <div id="selected-games-list">
                <!-- Selected games will appear here -->
            </div>
        </section>

        <section id="game-selection">
            <h2>Popular Games:</h2>
            <div class="search-container">
                <input type="text" id="game-search" placeholder="Search for games...">
                <select id="platform-filter">
                    <option value="">All Platforms</option>
                    <option value="187">PlayStation 5</option>
                    <option value="186">Xbox Series X</option>
                    <option value="4">PC</option>
                    <option value="7">Nintendo Switch</option>
                    <option value="18">PlayStation 4</option>
                    <option value="1">Xbox One</option>
                </select>
            </div>
            <div id="game-list">
                <!-- Games will be loaded dynamically -->
            </div>
        </section>

        <section id="recommendations">
            <h2>Recommended Games:</h2>
            <div id="recommendation-list">
                <!-- Recommendations will appear here -->
            </div>
        </section>
    </main>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>



        const apiKey = '70d54f37a8bf46bfa64f0e09f2b3b0f0';
        const apiUrl = 'https://api.rawg.io/api/games';
        const selectedGames = new Set();
        let currentGameId = null; // Add this line

        // Initialize Supabase client
        const supabaseUrl = 'https://rfgsqgnrjksygbsqwwcz.supabase.co'
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJmZ3NxZ25yamtzeWdic3F3d2N6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzU1MTI0NjcsImV4cCI6MjA1MTA4ODQ2N30.EymPclC3kMZPScDnBeA3beg9gVb0UE4EdqQT9z-DLIY'
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey)

        // Add these functions BEFORE loadComments
        function setupReplyHandlers() {
            document.querySelectorAll('.reply-button').forEach(button => {
                button.onclick = (e) => {
                    e.preventDefault();
                    const commentId = button.closest('.comment').dataset.commentId;
                    toggleReplyForm(commentId);
                };
            });

            document.querySelectorAll('.view-replies-button').forEach(button => {
                button.onclick = (e) => {
                    e.preventDefault();
                    const commentId = button.closest('.comment').dataset.commentId;
                    toggleReplies(commentId);
                };
            });
        }

        function toggleReplyForm(commentId) {
            const replyForm = document.getElementById(`reply-form-${commentId}`);
            replyForm.classList.toggle('active');
        }

        function toggleReplies(commentId) {
            const repliesContainer = document.getElementById(`replies-${commentId}`);
            const button = repliesContainer.previousElementSibling;
            repliesContainer.classList.toggle('hidden');
            
            if (repliesContainer.classList.contains('hidden')) {
                button.textContent = 'Show replies';
            } else {
                button.textContent = 'Hide replies';
            }
        }

        function organizeCommentsTree(comments) {
            const commentMap = new Map();
            const rootComments = [];

            comments.forEach(comment => {
                comment.replies = [];
                commentMap.set(comment.id, comment);
            });

            comments.forEach(comment => {
                if (comment.parent_id) {
                    const parentComment = commentMap.get(comment.parent_id);
                    if (parentComment) {
                        parentComment.replies.push(comment);
                    }
                } else {
                    rootComments.push(comment);
                }
            });

            return rootComments;
        }

        // Updated loadComments function
        async function loadComments(gameId) {
            console.log('Loading comments for game:', gameId);
            try {
                const { data, error } = await supabaseClient
                    .from('comments')
                    .select('*')
                    .eq('game_id', gameId)
                    .order('created_at', { ascending: true });

                if (error) throw error;

                const rootComments = organizeCommentsTree(data);
                const commentsContainer = document.querySelector('.comments-container');
                
                if (!commentsContainer) {
                    console.error('Comments container not found!');
                    return;
                }

                commentsContainer.innerHTML = renderComments(rootComments);
                setupReplyHandlers();
            } catch (error) {
                console.error('Error loading comments:', error);
            }
        }

        // Function to render comments recursively
        function renderComments(comments, depth = 0) {
            return comments.map(comment => `
                <div class="comment" data-comment-id="${comment.id}">
                    <div class="comment-avatar">
                        ${comment.user_name.charAt(0).toUpperCase()}
                    </div>
                    <div class="comment-content">
                        <div class="comment-header">
                            <span class="comment-author">${comment.user_name}</span>
                            <span class="comment-date">${new Date(comment.created_at).toLocaleDateString()}</span>
                        </div>
                        <div class="comment-text">${comment.comment_text}</div>
                        <div class="comment-actions">
                            <button class="reply-button" onclick="toggleReplyForm(${comment.id})">
                                Reply
                            </button>
                        </div>
                        <div class="reply-form" id="reply-form-${comment.id}">
                            <input type="text" class="reply-name" placeholder="Your name">
                            <textarea class="reply-text" placeholder="Write a reply..."></textarea>
                            <button onclick="submitReply(${comment.id})">Post Reply</button>
                        </div>
                        ${comment.replies.length > 0 ? `
                            <button class="view-replies-button" onclick="toggleReplies(${comment.id})">
                                ${comment.replies.length} ${comment.replies.length === 1 ? 'reply' : 'replies'}
                            </button>
                            <div class="replies-container" id="replies-${comment.id}">
                                ${renderComments(comment.replies, depth + 1)}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `).join('');
        }

        // Function to submit a reply
        async function submitReply(parentId) {
            const replyForm = document.getElementById(`reply-form-${parentId}`);
            const userName = replyForm.querySelector('.reply-name').value;
            const replyText = replyForm.querySelector('.reply-text').value;
            
            console.log('Current game ID:', currentGameId); // Debug log
            
            if (!currentGameId) {
                console.error('No game ID found');
                alert('Error: Could not determine which game this reply belongs to');
                return;
            }

            try {
                const { data, error } = await supabaseClient
                    .from('comments')
                    .insert({
                        game_id: parseInt(currentGameId),
                        user_name: userName,
                        comment_text: replyText,
                        parent_id: parseInt(parentId)
                    })
                    .select();

                if (error) {
                    console.error('Supabase error:', error);
                    throw error;
                }

                console.log('Reply submitted successfully:', data);

                // Reload comments to show the new reply
                await loadComments(currentGameId);
                
                // Clear and hide the reply form
                replyForm.querySelector('.reply-name').value = '';
                replyForm.querySelector('.reply-text').value = '';
                replyForm.classList.remove('active');
            } catch (error) {
                console.error('Error submitting reply:', error);
                alert('Failed to submit reply. Please try again.');
            }
        }

        async function addComment(gameId, userName, commentText) {
            console.log('Adding comment:', { gameId, userName, commentText });
            try {
                const { data, error } = await supabaseClient
                    .from('comments')
                    .insert([
                        {
                            game_id: gameId,
                            user_name: userName,
                            comment_text: commentText
                        }
                    ])
                    .select();

                console.log('Comment added:', data);
                console.log('Any errors:', error);

                if (error) throw error;

                // Reload comments to show the new one
                await loadComments(gameId);
                
                // Clear the form
                document.getElementById('commenter-name').value = '';
                document.getElementById('comment-text').value = '';
            } catch (error) {
                console.error('Error adding comment:', error);
            }
        }

        // 1. Core Scoring Functions
        function calculateCoreSimilarity(selectedGame, candidateGame) {
            const genreSimilarity = calculateGenreSimilarity(selectedGame.genres, candidateGame.genres);
             const tagSimilarity = calculateTagSimilarity(selectedGame.tags, candidateGame.tags);
            const mechanicsSimilarity = calculateMechanicsSimilarity(selectedGame, candidateGame);
            const nameSimilarity = calculateNameSimilarity(selectedGame.name, candidateGame.name);

            return {
                score: (
                    genreSimilarity * 0.3 + 
                    tagSimilarity * 0.2 + 
                    mechanicsSimilarity * 0.2 +
                    nameSimilarity * 0.3        // Added significant weight to name similarity
                ),
                details: {
                    genreScore: genreSimilarity,
                    tagScore: tagSimilarity,
                    mechanicsScore: mechanicsSimilarity,
                    nameSimilarity: nameSimilarity
                }
            };
        }

        function calculateQualityScore(game) {
            const metacriticScore = game.metacritic ? game.metacritic / 100 : 0;
            const userRatingScore = game.rating ? game.rating / game.rating_top : 0;
            const popularityScore = Math.min(game.ratings_count / 10000, 1); // Normalize to max 10000 ratings

            return {
                score: (metacriticScore * 0.4 + userRatingScore * 0.4 + popularityScore * 0.2),
                details: {
                    metacritic: metacriticScore,
                    userRating: userRatingScore,
                    popularity: popularityScore
                }
            };
        }

        function calculateRelevanceScore(game) {
            // Release date scoring (newer games score higher)
            const releaseDate = new Date(game.released);
            const now = new Date();
            const yearsDiff = (now - releaseDate) / (1000 * 60 * 60 * 24 * 365);
            const releaseDateScore = Math.max(0, 1 - (yearsDiff / 10)); // Linear decay over 10 years

            // Platform availability
            const platformScore = game.platforms ? Math.min(game.platforms.length / 5, 1) : 0;

            return {
                score: (releaseDateScore * 0.6 + platformScore * 0.4),
                details: {
                    releaseDate: releaseDateScore,
                    platforms: platformScore
                }
            };
        }

        function calculateTechnicalScore(selectedGame, candidateGame) {
            // Developer matching
            const developerMatch = haveSameDeveloper(selectedGame.developers, candidateGame.developers);
            
            // Game modes matching
            const gameModeScore = calculateGameModeSimilarity(selectedGame.game_modes, candidateGame.game_modes);
            
            // ESRB rating similarity
            const esrbMatch = selectedGame.esrb_rating?.id === candidateGame.esrb_rating?.id ? 1 : 0;

            return {
                score: (developerMatch * 0.3 + gameModeScore * 0.4 + esrbMatch * 0.3),
                details: {
                    developer: developerMatch,
                    gameModes: gameModeScore,
                    esrb: esrbMatch
                }
            };
        }

        function calculateDeveloperPublisherScore(selectedGame, candidateGame) {
            // Check developers match
            const developerMatch = haveSameDeveloper(selectedGame.developers, candidateGame.developers);
            
            // Check publishers match
            const publisherMatch = haveSamePublisher(selectedGame.publishers, candidateGame.publishers);

            return {
                score: (
                    developerMatch * 0.5 +       // 50% for same developer
                    publisherMatch * 0.5         // 50% for same publisher
                ),
                details: {
                    developerMatch,
                    publisherMatch,
                    companies: {
                        developers: candidateGame.developers?.map(d => d.name) || [],
                        publishers: candidateGame.publishers?.map(p => p.name) || []
                    }
                }
            };
        }

        function haveSameDeveloper(devs1, devs2) {
            if (!devs1?.length || !devs2?.length) return 0;
            return devs1.some(d1 => devs2.some(d2 => d1.id === d2.id)) ? 1 : 0;
        }

        function haveSamePublisher(pubs1, pubs2) {
            if (!pubs1?.length || !pubs2?.length) return 0;
            return pubs1.some(p1 => pubs2.some(p2 => p1.id === p2.id)) ? 1 : 0;
        }

        // 2. Main Ranking Function
        function rankGame(candidateGame, selectedGames) {
            const scores = selectedGames.map(selectedGame => {
                const coreSim = calculateCoreSimilarity(selectedGame, candidateGame);
                const technical = calculateTechnicalScore(selectedGame, candidateGame);
                const devPubScore = calculateDeveloperPublisherScore(selectedGame, candidateGame);
                
                return {
                    selectedGame: selectedGame.name,
                    coreSimilarity: coreSim,
                    technical: technical,
                    devPubScore: devPubScore,
                    totalScore: (
                        coreSim.score * 0.4 + 
                        technical.score * 0.2 + 
                        devPubScore.score * 0.4    // Developer/Publisher weight
                    )
                };
            });

            const bestMatch = scores.reduce((a, b) => a.totalScore > b.totalScore ? a : b);
            const quality = calculateQualityScore(candidateGame);
            const relevance = calculateRelevanceScore(candidateGame);

            const finalScore = (
                bestMatch.coreSimilarity.score * 0.30 +    // Core Similarity: 30%
                quality.score * 0.20 +                      // Quality: 20%
                relevance.score * 0.20 +                    // Relevance: 20%
                bestMatch.devPubScore.score * 0.30         // Developer/Publisher: 30%
            );

            return {
                game: candidateGame,
                score: finalScore,
                details: {
                    bestMatchWith: bestMatch.selectedGame,
                    coreSimilarity: bestMatch.coreSimilarity.details,
                    quality: quality.details,
                    relevance: relevance.details,
                    devPub: bestMatch.devPubScore.details
                }
            };
        }

        // 3. Main Recommendation Function
        async function fetchRecommendations() {
            const recommendationList = document.getElementById('recommendation-list');
            recommendationList.innerHTML = '<p>Finding recommendations...</p>';
            const platformId = document.getElementById('platform-filter').value;

            try {
                // 1. Get full details of all selected games
                const selectedGamesDetails = [];
                for (const selectedId of selectedGames) {
                    const response = await fetch(`${apiUrl}/${selectedId}?key=${apiKey}`);
                    const gameDetails = await response.json();
                    selectedGamesDetails.push(gameDetails);
                }

                // 2. Get all unique genres from selected games
                const selectedGenres = new Set(
                    selectedGamesDetails.flatMap(game => game.genres.map(g => g.slug))
                );

                // 3. Fetch potential recommendations using genres
                const genreParam = Array.from(selectedGenres).join(',');
                let url = `${apiUrl}?key=${apiKey}&genres=${genreParam}&page_size=40&ordering=-rating`;
                if (platformId) {
                    url += `&platforms=${platformId}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                // 4. Get series name for additional search
                const seriesNames = selectedGamesDetails.map(game => 
                    game.name.toLowerCase().split(/\d/)[0].trim()
                );

                // 5. Fetch additional games by series names
                let allCandidates = [...data.results];
                
                for (const seriesName of seriesNames) {
                    if (seriesName.length > 3) {
                        let seriesUrl = `${apiUrl}?key=${apiKey}&search=${seriesName}&page_size=20`;
                        if (platformId) {
                            seriesUrl += `&platforms=${platformId}`;
                        }
                        const seriesResponse = await fetch(seriesUrl);
                        const seriesData = await seriesResponse.json();
                        allCandidates = [...allCandidates, ...seriesData.results];
                    }
                }

                // 6. Remove duplicates by ID
                allCandidates = Array.from(
                    new Map(allCandidates.map(game => [game.id, game])).values()
                );

                // 7. Split and rank candidates into two groups
                const allRankedGames = allCandidates
                    .filter(game => !selectedGames.has(game.id))
                    .map(game => rankGame(game, selectedGamesDetails));

                // Split into series/developer matches and other recommendations
                const seriesMatches = allRankedGames
                    .filter(({game, score, details}) => 
                        !selectedGames.has(game.id.toString()) &&  // Add this check
                        (details.coreSimilarity.nameSimilarity > 0.8 || 
                        details.devPub.developerMatch || 
                        details.devPub.publisherMatch)
                    )
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 4); // Limit to top 4 series matches

                const otherRecommendations = allRankedGames
                    .filter(({game, score, details}) => 
                        !selectedGames.has(game.id.toString()) &&  // Add this check
                        details.coreSimilarity.nameSimilarity <= 0.8 && 
                        !details.devPub.developerMatch && 
                        !details.devPub.publisherMatch
                    )
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 4); // Limit to top 4 other recommendations

                // 8. Display recommendations in sections
                recommendationList.innerHTML = '';

                // Create container for both sections
                const container = document.createElement('div');
                container.className = 'recommendation-container';

                // Series/Developer Matches Section
                const seriesSection = document.createElement('div');
                seriesSection.className = 'recommendation-section';
                seriesSection.innerHTML = `<h2 class="section-title">Series & Developer Matches</h2>`;

                const seriesGames = document.createElement('div');
                seriesGames.className = 'section-games';

                if (seriesMatches.length > 0) {
                    seriesMatches.forEach(({game, score, details}) => {
                        const gameElement = createGameElement(game, score, details);
                        seriesGames.appendChild(gameElement);
                    });
                } else {
                    seriesGames.innerHTML = '<p style="grid-column: 1/-1; text-align: center; padding: 2rem; color: var(--text-light);">No series or developer matches found for your selected games.</p>';
                }

                seriesSection.appendChild(seriesGames);

                // Other Recommendations Section
                const otherSection = document.createElement('div');
                otherSection.className = 'recommendation-section';
                otherSection.innerHTML = `<h2 class="section-title">Similar Games</h2>`;

                const otherGames = document.createElement('div');
                otherGames.className = 'section-games';

                if (otherRecommendations.length > 0) {
                    otherRecommendations.forEach(({game, score, details}) => {
                        const gameElement = createGameElement(game, score, details);
                        otherGames.appendChild(gameElement);
                    });
                } else {
                    otherGames.innerHTML = '<p style="grid-column: 1/-1; text-align: center; padding: 2rem; color: var(--text-light);">No similar games found. Try selecting different games.</p>';
                }

                otherSection.appendChild(otherGames);

                // Add both sections to container
                container.appendChild(seriesSection);
                container.appendChild(otherSection);
                recommendationList.appendChild(container);

            } catch (error) {
                console.error('Error in recommendation system:', error);
                recommendationList.innerHTML = '<p>Error finding recommendations. Please try again.</p>';
            }
        }

        // Helper function to create game elements
        function createGameElement(game, score, details) {
            console.log('Creating game element for:', game.name);
            
            const gameElement = document.createElement('div');
            gameElement.className = 'game';
            gameElement.dataset.gameId = game.id;
            
            // Make it visually distinct and clickable
            gameElement.style.cursor = 'pointer';
            
            // Add the HTML content
            gameElement.innerHTML = `
                <img src="${game.background_image}" alt="${game.name}">
                <h3>${game.name}</h3>
                <p><strong>Match Score:</strong> ${(score * 100).toFixed(0)}%</p>
                <div class="match-details">
                    <small>Release: ${game.released}</small><br>
                    <small>Platforms: ${game.platforms?.map(p => p.platform.name).join(', ') || 'Unknown'}</small><br>
                    <small>Genres: ${game.genres.map(g => g.name).join(', ')}</small><br>
                    <strong>Developer:</strong> ${game.developers?.map(d => d.name).join(', ') || 'Unknown'}<br>
                    <strong>Publisher:</strong> ${game.publishers?.map(p => p.name).join(', ') || 'Unknown'}<br>
                    ${details.coreSimilarity.nameSimilarity > 0.8 ? '<p class="match-highlight">Same Series! 🎮</p>' : ''}
                    ${details.devPub.developerMatch ? '<p class="match-highlight">Same Developer! 👨‍💻</p>' : ''}
                    ${details.devPub.publisherMatch ? '<p class="match-highlight">Same Publisher! 🎮</p>' : ''}
                </div>
            `;

            // Single click handler to show popup
            gameElement.addEventListener('click', async function() {
                console.log('Game clicked:', game.name);
                const popup = document.getElementById('game-popup');
                const content = popup.querySelector('.popup-content');
                
                // Set the current game ID immediately when clicking
                currentGameId = game.id;
                console.log('Set currentGameId to:', currentGameId);
                
                try {
                    // Show loading state
                    popup.style.display = 'block';
                    content.innerHTML = '<div class="loading">Loading...</div>';
                    
                    // Fetch game details including stores
                    const response = await fetch(`${apiUrl}/${game.id}?key=${apiKey}`);
                    const gameDetails = await response.json();
                    
                    // Fetch stores
                    const storesUrl = `${apiUrl}/${game.id}/stores?key=${apiKey}`;
                    const storesResponse = await fetch(storesUrl);
                    const storesData = await storesResponse.json();
                    
                    // Process stores data - FIXED validation
                    let storesHTML = '';
                    if (storesData.results && storesData.results.length > 0) {
                        console.log('Number of stores found:', storesData.results.length);
                        
                        // Updated validation to only check for URL
                        const validStores = storesData.results.filter(storeData => storeData && storeData.url);
                        
                        console.log('Valid stores:', validStores);
                        
                        if (validStores.length > 0) {
                            storesHTML = `
                                <div class="detail-section stores-section">
                                    <h3>Where to Buy</h3>
                                    <div class="stores-grid">
                                        ${validStores.map(storeData => `
                                            <a href="${storeData.url}" 
                                               class="store-tag" 
                                               target="_blank" 
                                               rel="noopener noreferrer">
                                                <span class="store-name">${getStoreName(storeData.store_id)}</span>
                                            </a>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }
                    }
                    
                    if (!storesHTML) {
                        storesHTML = `
                            <div class="detail-section stores-section">
                                <h3>Where to Buy</h3>
                                <div class="stores-grid">
                                    <p>No store links available for this game.</p>
                                </div>
                            </div>
                        `;
                    }

                    // Add platforms HTML definition
                    const platformsHTML = gameDetails.platforms?.length ? `
                        <div class="detail-section platforms-section">
                            <h3>Available Platforms</h3>
                            <div class="platforms-grid">
                                ${gameDetails.platforms
                                    .filter(p => p && p.platform)
                                    .map(({ platform }) => 
                                        `<div class="platform-tag">
                                            <span class="platform-name">${platform.name || 'Unknown Platform'}</span>
                                        </div>`
                                    ).join('')}
                            </div>
                        </div>
                    ` : '';

                    // Add genres HTML definition
                    const genresHTML = gameDetails.genres?.length ? `
                        <div class="detail-section genres-section">
                            <h3>Genres</h3>
                            <div class="genres-grid">
                                ${gameDetails.genres
                                    .filter(genre => genre && genre.name)
                                    .map(genre => 
                                        `<div class="genre-tag">
                                            <span class="genre-name">${genre.name}</span>
                                        </div>`
                                    ).join('')}
                            </div>
                        </div>
                    ` : '';

                    // Add store name mapping function
                    function getStoreName(storeId) {
                        const storeNames = {
                            1: 'Steam',
                            2: 'Xbox Store',
                            3: 'PlayStation Store',
                            4: 'App Store',
                            5: 'GOG',
                            6: 'Nintendo Store',
                            7: 'Xbox 360 Store',
                            8: 'Google Play',
                            9: 'itch.io',
                            11: 'Epic Games'
                        };
                        return storeNames[storeId] || 'Unknown Store';
                    }

                    // Check if this is a recommended game
                    const isRecommended = this.hasAttribute('data-match-details');
                    const matchDetails = isRecommended ? JSON.parse(this.getAttribute('data-match-details')) : null;
                    
                    // Prepare match details section
                    const matchDetailsHTML = isRecommended ? `
                        <div class="detail-section">
                            <h3>Why This Game?</h3>
                            <div class="match-reasons">
                                ${matchDetails.coreSimilarity.nameSimilarity > 0.8 ? 
                                    '<div class="platform-tag"><span class="platform-name">✓ Same game series</span></div>' : ''}
                                ${matchDetails.devPub.developerMatch ? 
                                    '<div class="platform-tag"><span class="platform-name">✓ Same developer</span></div>' : ''}
                                ${matchDetails.devPub.publisherMatch ? 
                                    '<div class="platform-tag"><span class="platform-name">✓ Same publisher</span></div>' : ''}
                                <div class="platform-tag">
                                    <span class="platform-name">Match Score: ${(matchDetails.score * 100).toFixed(0)}%</span>
                                </div>
                            </div>
                        </div>
                    ` : '';

                    content.innerHTML = `
                        <button class="close-popup">×</button>
                        <div class="popup-header">
                            <div class="popup-image-container">
                                <img class="popup-image" src="${gameDetails.background_image || ''}" alt="${gameDetails.name || 'Game'}" onerror="this.src='placeholder.jpg'">
                            </div>
                            <div class="popup-title-section">
                                <h2 class="popup-title">${gameDetails.name || 'Unknown Game'}</h2>
                                <div class="popup-meta">
                                    <span class="release-date">Released: ${gameDetails.released || 'TBA'}</span>
                                    <span class="rating">Rating: ${gameDetails.rating || '0'}/5</span>
                                </div>
                            </div>
                        </div>
                        <div class="popup-body">
                            <div class="description">${gameDetails.description || 'No description available.'}</div>
                            <div class="details-grid">
                                ${platformsHTML}
                                ${storesHTML}
                                ${genresHTML}
                                ${matchDetailsHTML}
                            </div>
                            <div class="comments-section">
                                <h3>Comments</h3>
                                <div class="comments-container">
                                    <!-- Comments will be loaded here -->
                                </div>
                                <form id="comment-form" class="comment-form">
                                    <input type="text" id="commenter-name" placeholder="Your name" required>
                                    <textarea id="comment-text" placeholder="Add a comment..." required></textarea>
                                    <button type="submit">Post Comment</button>
                                </form>
                            </div>
                        </div>
                    `;

                    // Add close button functionality
                    const closeButton = popup.querySelector('.close-popup');
                    closeButton.addEventListener('click', () => {
                        popup.style.display = 'none';
                    });
                    
                    // Load comments for this game
                    await loadComments(currentGameId);

                    // Set up comment form submission
                    const commentForm = document.getElementById('comment-form');
                    if (commentForm) {
                        console.log('Found comment form, setting up submission');
                        commentForm.onsubmit = async (e) => {
                            e.preventDefault();
                            console.log('Form submitted');
                            
                            const userName = document.getElementById('commenter-name').value;
                            const commentText = document.getElementById('comment-text').value;
                            
                            console.log('Submitting comment:', { currentGameId, userName, commentText });
                            await addComment(currentGameId, userName, commentText);
                        };
                    } else {
                        console.error('Comment form not found!');
                    }
                } catch (error) {
                    console.error('Error loading game details:', error);
                    console.error('Error stack:', error.stack);
                    content.innerHTML = `
                        <div class="error">
                            <h3>Error loading game details</h3>
                            <p>${error.message}</p>
                            <button class="close-popup">×</button>
                        </div>
                    `;
                }
            });

            // In the recommendation section where game elements are created
            gameElement.setAttribute('data-match-details', JSON.stringify({
                coreSimilarity: details.coreSimilarity,
                devPub: details.devPub,
                score: score
            }));

            return gameElement;
        }

        // Helper functions (from previous implementation)
        function calculateGenreSimilarity(genres1, genres2) {
            if (!genres1?.length || !genres2?.length) return 0;
            const set1 = new Set(genres1.map(g => g.id));
            const set2 = new Set(genres2.map(g => g.id));
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            return intersection.size / union.size;
        }

        function calculateTagSimilarity(tags1, tags2) {
            if (!tags1?.length || !tags2?.length) return 0;
            const set1 = new Set(tags1.map(t => t.id));
            const set2 = new Set(tags2.map(t => t.id));
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            return intersection.size / union.size;
        }

        function calculateMechanicsSimilarity(game1, game2) {
            // Simplified mechanics comparison using tags and genres
            const tagSim = calculateTagSimilarity(game1.tags, game2.tags);
            const genreSim = calculateGenreSimilarity(game1.genres, game2.genres);
            return (tagSim + genreSim) / 2;
        }

        function calculateGameModeSimilarity(modes1, modes2) {
            if (!modes1?.length || !modes2?.length) return 0;
            const set1 = new Set(modes1.map(m => m.id));
            const set2 = new Set(modes2.map(m => m.id));
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            return intersection.size / union.size;
        }

        // Debounce function to limit API calls
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Add this shuffle function before fetchGames
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Update the hidden gems part in fetchGames
        async function fetchGames(searchQuery = '') {
            const gameList = document.getElementById('game-list');
            gameList.classList.add('loading');
            
            try {
                const platformId = document.getElementById('platform-filter').value;
                let url;
                
                if (searchQuery) {
                    // Search query handling with popularity ordering
                    url = `${apiUrl}?key=${apiKey}&search=${searchQuery}&page_size=40&ordering=-metacritic,-rating,-added`;
                    if (platformId) {
                        url += `&platforms=${platformId}`;
                    }
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    // Sort results by popularity metrics
                    const sortedResults = data.results.sort((a, b) => {
                        // Calculate popularity score
                        const getPopularityScore = (game) => {
                            let score = 0;
                            if (game.metacritic) score += game.metacritic;
                            if (game.ratings_count) score += Math.min(game.ratings_count / 1000, 50);
                            if (game.rating) score += game.rating * 10;
                            return score;
                        };

                        return getPopularityScore(b) - getPopularityScore(a);
                    });
                    
                    // Display sorted search results
                    displayGames(sortedResults.slice(0, 12));
                    
                } else {
                    // Initial view with popular games
                    url = `${apiUrl}?key=${apiKey}&ordering=-rating,-metacritic,-added&page_size=40&metacritic=80,100&ratings_count=1000`;
                    if (platformId) {
                        url += `&platforms=${platformId}`;
                    }
                    
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    // Filter for popular games
                    const popularGames = data.results
                        .filter(game => game.metacritic > 80 || game.ratings_count > 1000)
                        .slice(0, 8);

                    // Fetch hidden gems
                    const hiddenGemsUrl = `${apiUrl}?key=${apiKey}&ordering=-rating&page_size=100&dates=2019-01-01,${new Date().toISOString().split('T')[0]}&metacritic=75,100&ratings_count=100,1000`;
                    if (platformId) {
                        hiddenGemsUrl += `&platforms=${platformId}`;
                    }
                    const hiddenGemsResponse = await fetch(hiddenGemsUrl);
                    const hiddenGemsData = await hiddenGemsResponse.json();
                    
                    const allHiddenGems = hiddenGemsData.results.filter(isHiddenGem);
                    const randomHiddenGems = shuffleArray(allHiddenGems).slice(0, 4);

                    // Combine and display games
                    const combinedGames = [...popularGames, ...randomHiddenGems];
                    displayGames(combinedGames);
                }
            } catch (error) {
                console.error('Error fetching games:', error);
                gameList.innerHTML = '<p>Error loading games. Please try again.</p>';
            } finally {
                gameList.classList.remove('loading');
            }
        }

        // Update displayGames to handle hidden gems
        function displayGames(games) {
            const gameList = document.getElementById('game-list');
            gameList.innerHTML = '';

            games.forEach(game => {
                const gameElement = document.createElement('div');
                
                // Check if this game is in the recommendation sections
                const isRecommended = document.querySelector(
                    `.recommendation-section .section-games [data-game-id="${game.id}"]`
                ) !== null;
                
                gameElement.className = 'game';
                gameElement.dataset.gameId = game.id;
                
                // Visual indicators (only for popular games now)
                const isPopular = game.metacritic > 85 || game.ratings_count > 1000;
                const starHtml = isPopular ? '<span class="popular-star">★</span>' : '';
                
                gameElement.innerHTML = `
                    ${starHtml}
                    <img src="${game.background_image}" alt="${game.name}">
                    <h3>${game.name}</h3>
                    <div class="game-details">
                        ${game.metacritic ? `<p><strong>Metacritic:</strong> ${game.metacritic}</p>` : ''}
                        <p><strong>Release:</strong> ${game.released || 'TBA'}</p>
                        <p><strong>Rating:</strong> ${game.rating}/5 (${game.ratings_count} reviews)</p>
                        <p><strong>Platforms:</strong> ${game.platforms?.map(p => p.platform.name).join(', ') || 'Unknown'}</p>
                        <p><strong>Genres:</strong> ${game.genres.map(g => g.name).join(', ')}</p>
                    </div>
                `;

                // Add click handler
                gameElement.addEventListener('click', () => {
                    // For regular games in the search/popular section
                    toggleGameSelection(game);
                });
                
                gameList.appendChild(gameElement);
            });
        }

        // Initialize games
        document.addEventListener('DOMContentLoaded', () => {
            // Add empty popup container
            const popupHTML = `
                <div id="game-popup" class="game-popup">
                    <div class="popup-overlay"></div>
                    <div class="popup-content">
                        <!-- Content will be dynamically inserted -->
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', popupHTML);

            // Initialize games
            fetchGames();
        });

        // Move these functions outside the DOMContentLoaded event
        function updatePopupContent(gameDetails) {
            currentGameId = gameDetails.id;  // Add this line at the start of the function
            const popup = document.getElementById('game-popup');
            popup.dataset.gameId = gameDetails.id;  // Also store it in the popup
            const content = popup.querySelector('.popup-content');
            
            content.innerHTML = `
                <button class="close-popup">×</button>
                <div class="popup-header">
                    <div class="popup-image-container">
                        <img class="popup-image" src="${gameDetails.background_image}" alt="${gameDetails.name}">
                    </div>
                    <div class="popup-title-section">
                        <h2 class="popup-title">${gameDetails.name}</h2>
                        <div class="popup-meta">
                            <span class="release-date">Released: ${gameDetails.released}</span>
                            <span class="rating">Rating: ${gameDetails.rating}/5</span>
                        </div>
                    </div>
                </div>
                <div class="popup-body">
                    <div class="description">${gameDetails.description}</div>
                    <div class="details-grid">
                        <div class="detail-section platforms-section">
                            <h3>Available Platforms</h3>
                            <div class="platforms-grid">
                                ${gameDetails.platforms?.map(({ platform }) => 
                                    `<div class="platform-tag">
                                        <span class="platform-name">${platform.name}</span>
                                    </div>`
                                ).join('')}
                            </div>
                        </div>
                        <div class="detail-section genres-section">
                            <h3>Genres</h3>
                            <div class="genres-grid">
                                ${gameDetails.genres?.map(genre => 
                                    `<div class="genre-tag">
                                        <span class="genre-name">${genre.name}</span>
                                    </div>`
                                ).join('')}
                            </div>
                        </div>
                        <div class="detail-section">
                            <h3>Why This Game?</h3>
                            <div class="match-reasons">
                                ${details.coreSimilarity.nameSimilarity > 0.8 ? '<p>✓ Same game series</p>' : ''}
                                ${details.devPub.developerMatch ? '<p>✓ Same developer</p>' : ''}
                                ${details.devPub.publisherMatch ? '<p>✓ Same publisher</p>' : ''}
                                <p>Match Score: ${(score * 100).toFixed(0)}%</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Re-add event listener for close button
            const closeButton = popup.querySelector('.close-popup');
            if (closeButton) {
                closeButton.addEventListener('click', () => {
                    popup.style.display = 'none';
                });
            }
        }

        // Add hidden gems section
        function isHiddenGem(game) {
            const MAJOR_PUBLISHERS = [
                'Electronic Arts', 'EA', 'Ubisoft', 'Activision', 'Nintendo', 
                'Sony', 'Microsoft', 'Bethesda', 'Square Enix', '2K Games',
                'Bandai Namco', 'Capcom', 'Sega', 'Take-Two Interactive'
            ];

            return (
                (game.rating >= 4 || game.metacritic >= 75) && // High quality
                game.ratings_count >= 100 && // Enough ratings to be credible
                game.ratings_count < 1000 && // Not too popular
                game.released && // Must have release date
                new Date(game.released) >= new Date(Date.now() - 5 * 365 * 24 * 60 * 60 * 1000) && // Last 5 years
                !MAJOR_PUBLISHERS.some(pub => 
                    game.publishers?.some(p => 
                        p.name.toLowerCase().includes(pub.toLowerCase())
                    )
                )
            );
        }

        // Function to handle game selection
        function toggleGameSelection(game) {
            const gameElement = document.querySelector(`.game[data-game-id="${game.id}"]`);
            
            if (!selectedGames.has(game.id.toString())) {
                // Selecting a new game
                console.log('Selecting game:', game.name);
                selectedGames.add(game.id.toString());
                
                // Add selected visual effects
                gameElement.classList.add('selected');
                gameElement.style.transform = 'translateY(-8px) rotate(2deg)';
                gameElement.style.boxShadow = '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)';
                
                // Add to selected games list
                addToSelectedList(game);
                
                // If we have selected games, fetch recommendations
                if (selectedGames.size > 0) {
                    fetchRecommendations();
                }
            } else {
                // Deselecting the game
                console.log('Deselecting game:', game.name);
                selectedGames.delete(game.id.toString());
                
                // Remove selected visual effects
                gameElement.classList.remove('selected');
                gameElement.style.transform = '';
                gameElement.style.boxShadow = '';
                
                // Remove from selected games list
                removeFromSelectedList(game.id);
                
                // Clear recommendations if no games selected
                if (selectedGames.size === 0) {
                    document.getElementById('recommendation-list').innerHTML = '';
                }
            }
            
            updateSelectedCount();
        }

        // Update the addToSelectedList function
        function addToSelectedList(game) {
            const selectedGamesList = document.getElementById('selected-games-list');
            
            // Check if the game is already in the list
            if (selectedGamesList.querySelector(`[data-game-id="${game.id}"]`)) {
                return;
            }
            
            const gameElement = document.createElement('div');
            gameElement.className = 'game';
            gameElement.dataset.gameId = game.id;
            gameElement.innerHTML = `
                <img src="${game.background_image}" alt="${game.name}">
                <h3>${game.name}</h3>
                <div class="game-details">
                    ${game.metacritic ? `<p><strong>Metacritic:</strong> ${game.metacritic}</p>` : ''}
                    <p><strong>Release:</strong> ${game.released || 'TBA'}</p>
                    <p><strong>Rating:</strong> ${game.rating}/5 (${game.ratings_count} reviews)</p>
                    <p><strong>Platforms:</strong> ${game.platforms?.map(p => p.platform.name).join(', ') || 'Unknown'}</p>
                    <p><strong>Genres:</strong> ${game.genres.map(g => g.name).join(', ')}</p>
                </div>
            `;
            
            // Add click handler to remove game
            gameElement.addEventListener('click', () => {
                removeGame(game.id);
            });
            
            selectedGamesList.appendChild(gameElement);
            console.log('Added game to selected list:', game.name);
        }

        // Function to remove game from selected list
        function removeFromSelectedList(gameId) {
            const selectedGamesList = document.getElementById('selected-games-list');
            const gameElement = selectedGamesList.querySelector(`[data-game-id="${gameId}"]`);
            if (gameElement) {
                gameElement.remove();
            }
            
            // Also reset visual effects in the main game list
            const mainGameElement = document.querySelector(`.game[data-game-id="${gameId}"]`);
            if (mainGameElement) {
                mainGameElement.classList.remove('selected');
                mainGameElement.style.transform = '';
                mainGameElement.style.boxShadow = '';
            }
        }

        // Function to remove game
        function removeGame(gameId) {
            selectedGames.delete(gameId.toString());
            
            // Remove from selected games list
            removeFromSelectedList(gameId);
            
            // Remove selected class from game in main list
            const gameElement = document.querySelector(`.game[data-game-id="${gameId}"]`);
            if (gameElement) {
                gameElement.classList.remove('selected');
            }
            
            // Update recommendations
            if (selectedGames.size > 0) {
                fetchRecommendations();
            } else {
                document.getElementById('recommendation-list').innerHTML = '';
            }
            
            updateSelectedCount();
        }

        // Set up search functionality
        const searchInput = document.getElementById('game-search');
        searchInput.addEventListener('input', debounce(e => fetchGames(e.target.value), 500));

        // Add new name similarity function
        function calculateNameSimilarity(name1, name2) {
            // Clean and normalize names
            const cleanName1 = name1.toLowerCase().replace(/[^a-z0-9\s]/g, '');
            const cleanName2 = name2.toLowerCase().replace(/[^a-z0-9\s]/g, '');
            
            // Extract series name (words before numbers)
            const series1 = cleanName1.split(/\d/).shift().trim();
            const series2 = cleanName2.split(/\d/).shift().trim();
            
            // Perfect series match
            if (series1 && series2 && series1 === series2) {
                return 1;
            }
            
            // Check for partial series match (e.g., "forza horizon" vs "forza")
            if (series1 && series2) {
                if (series1.includes(series2) || series2.includes(series1)) {
                    return 0.8;
                }
            }
            
            // Check for word overlap
            const words1 = new Set(cleanName1.split(' '));
            const words2 = new Set(cleanName2.split(' '));
            const commonWords = [...words1].filter(word => words2.has(word));
            
            if (commonWords.length > 0) {
                return 0.3 + (0.2 * commonWords.length);
            }
            
            return 0;
        }

        function updateSelectedCount() {
            const selectedCount = selectedGames.size;
            console.log('Updating selected count:', selectedCount);
            
            // Update the counter display
            const counter = document.getElementById('selected-counter');
            if (counter) {
                counter.textContent = `${selectedCount} game${selectedCount !== 1 ? 's' : ''} selected`;
            }
            
            // Show/hide the clear button based on selection
            const clearButton = document.getElementById('clear-selection');
            if (clearButton) {
                clearButton.style.display = selectedCount > 0 ? 'block' : 'none';
            }
            
            // Enable/disable the get recommendations button
            const recommendButton = document.getElementById('get-recommendations');
            if (recommendButton) {
                recommendButton.disabled = selectedCount === 0;
                recommendButton.classList.toggle('disabled', selectedCount === 0);
            }
        }

    </script>
    
    <!-- Add this right before the closing body tag -->
    <script>
        console.log('Script loaded');
        
        // Theme switch functionality
        const toggleSwitch = document.querySelector('#checkbox');
        console.log('Toggle switch:', toggleSwitch);
        
        if (toggleSwitch) {
            toggleSwitch.addEventListener('change', function(e) {
                console.log('Toggle clicked');
                if (e.target.checked) {
                    document.documentElement.setAttribute('data-theme', 'dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    document.documentElement.setAttribute('data-theme', 'light');
                    localStorage.setItem('theme', 'light');
                }
            });
        } else {
            console.error('Theme switch not found');
        }
    </script>
</body>
</html>
